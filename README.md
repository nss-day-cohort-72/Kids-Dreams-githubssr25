# Events and Debugging Assessment

Time to assess how well you have learned to use the debugging tools in Chrome Dev Tools, and writing click event listeners. This application is to show kids with illnesses and the memories the would like to make. Celebrities sign up to help kids make memories.

> ðŸ§¨ Make sure you answer the vocabulary and understanding questions at the end of this document before notifying your coaches that you are done with the project

## Event Listeners to Create

1. When the kid name is clicked, it should display their wish.
1. When the celebrity name is clicked, it should display their sport.
1. The pairings list should should contain the pairing in the following format.
    ```html
    {child name} will be making memories with {celebrity name}, a {celebrity sport} star, by {child wish}
    ```

Below is an animation showing how the application should look when complete and how the event listeners should work.

<img src="./images/debugging-events-assessment.gif" width="700px">

## Setup

Your instruction team will provide a link for you to create your assessment repository. Once your repo is created, clone it to your machine.

1. Make sure you are in your `workspace` directory.
1. `git clone {github repo SSH string}`.
1. `cd` into the directory it creates.
1. `code .` to open the project code.
1. Use the `serve` command to start the web server.
1. Open the URL provided in Chrome.

Make sure your Developer Tools are open at all times while working on this project. Use the messages provided in the Console to determine what code needs to be fixed or implemented, and use breakpoints in the Sources tab to step through your code as you debug.

## Vocabulary and Understanding

Before you click the "Complete Assessment" button on the Learning Platform, add your answers below each question and make a commit.

1. When a child is clicked on in the browser, which module contains the code that will execute on that event happening? Can you explain the algorithm of that logic?
   > Your answer here
The module that contains this logic is Kids.js to preface the answer below. 

Before talking about this logic to discuss the execution of an event lets make mention of the fact that the main.js module is the entry point of the application it will execute the code from our Kids.js(along with the other 2) and execute hte function Kids() which will generate HTML content for this part of the page. Once this HTML content is generated and injected into the DOM, the event listener is ready 
(and was set up via document.addEventListener call) and is waiting to respond to any click events for the entire document. 

Now relating to the specifics of the Kid.js module, once main.js calls the Kids() function, the Kids module will generate an ordered list<ol> of children with each child represented as a list item<li>. To each list item we use data- attributes(data-id, data-type, data-wish) to store information about the child. The data- attributes represent dataset which is relevant to the event listener which we will talk about in a minute for when a a click event actually happens that the event listener has to respond to. Right now we are just talking about the initial generation and rendering of the list of children that shows up on the page that you ultimately need to click to generate an event. But to get back to the Kids(), it will close the <li> elements that are generated for each child from the getKids() array we call from the database and close them with an </ol> tag when done. Once this HTML generated by Kids() function is done it can be inserted into DOM via mainContainer.innerHTML = applicationHTML(we are setting the applicationHTML string we created to be inserted into the main container and displayed by applying innerHTML). Now the kids names are actually displayed on the page(same process happens with CelebrityList.js and Pairings.js you can see below how we call all 3 below in main.js) we can actually have values that the user can see and click on to generate an event.
          <h2>Kids</h2>
            ${Kids()}
        </section>
        <section class="detail--column details__celebrities">
            <h2>Celebrities</h2>
            ${Celebrities()}
        </section>
    </article>

    <article class="assignments">
        <h2>Pairings</h2>
        ${Pairings()} 


In the context of Kids.js, when a user clicks on the child's name in the browser, teh click event is triggered, the event listener captures the click event and identifies the target element of hte event which will be childrenTarget(.target identifies what was clicked on).        const childrenTarget = clickEvt.target


 ChildrenTarget will represent the specific list <li> that was clicked. This is where  which I alluded to last paragraph comesdataset into play as a property on an HTML element that allows us to read and write custom data attributes in the HTML. We can essentially embed relevant info in HTML for later processing or displaying by Javascript. We defined then as using data- in our Kids() function 
     html += `<li data-id="${child.id}" data-childforeignkey="${child.celebrityId}" data-type="children" data-wish="${child.wish}"> Child name: ${child.name}</li>`

and this becomes crucial for this part of the code here 
    const childrenId = childrenTarget.dataset.id
        if(childrenTarget.dataset.type === "children"){

childrenId is able to obtain the value of the id we stored in the HTML element we clicked on(ie the <li> element that represented the specific child clicked) and childrenTarget.dataset.type is able to check on the type value we set within our li data-type="children". Its the code's way of verifying that the element clicked on was in fact a child(as opposed ots ay a celebrity) before proceeding with the for loop below. Note that the childrenTarget.dataset.id value we stored was a string we have to parse to an integer later on. 

Now by entering the for loop logic  for(const child of children){ we iterate through all the children from the database that we got via const children = getKids(). We iterate through each child until we find the one who's id value equals the <li> element we clicked on that was stored through dataset as we discussed earlier. When we find the one that matches   const childrenId = childrenTarget.dataset.id that is when we can display our window alert(note you could also use child.wish as well each child has an id, name, celebrityId and wish attribute that can be accessed)
 window.alert(` ${child.name} 's wish is ${childrenTarget.dataset.wish}`);


2. In the **Pairings** module, why must the `findCelebrityMatch()` function be invoked inside the `for..of` loop that iterates the kids array?
   > Your answer here

THe primary purpose of findCelebrityMatch() function is to identify and return the specific celebrity that corresponds to a particular child. This is where the concept of foreign keys will come into play as each child has a relationship with a specific celebrity where the child's celebrityID value refers to the id value of the celebrity themselves. This function will take the entire array of celebrities iterate through it and find the celebrity who has the id that matches the celebrityID of the kid who is also being passed in as a parameter 
to     
  for (const kid of kids) {
  const kidsStar = findCelebrityMatch(kid, celebrities). 

Note that this findCelebrity is done within the for loop right after const kid of kids. This is done so that each child can be processed one at a time before moving onto the next, we need to ensure that findCelebrityMatch() operates within the context of the current child. Each child has a unique celebrityId, and we need to pass in each child specifically as we iterate through     for (const kid of kids) { to figure out who the corresponding celebrity is with a value equal to the celebrityId value of the kid. We can then find the actual celebrity who corresponds to kidObject.celebrityid here 
  if(kidObject.celebrityId === celebrityVal.id){

        celebrity = celebrityVal;
 and return that value from findCelebrityMatch and use it in the Pairings() function which generates the HTML which we will display on the page. All of this allows for separation of concerns as well. The for loop just has to focus on iterating through each kid and using the specific celebrity object value obtained from the findCelebrityMatch() when generating the HTML string to display. The findCelebrityMatch() merely has to focus on just finding the single celebrity it is concerned with(ie matching the celebrity with the id of the kidObject passed in). If we did not place findCelebrityMatch() within the for loop of   for (const kid of kids) { we would have to do a for each loop for kids and also iterate through every celebrity to find the one with the corresponding ID all within one function(whether that is explicitly using another for each loop or using the .find method to find the first celebrity who's id matches the kidObject.celebrityId). Because you cant just display X number of combinations of kids/celebrities with the corresponding ID at once, we would have to store each combination and then retrieve those values and iterate through them to display them via the Pairings() function that generates HTML.So you can see how much more inefficient the code woudl be if we did not call findCelebrityMatch() within the for loop iterating through all the kids. 


3. In the **CelebrityList** module, can you describe how the name of the sport that the celebrity plays can be displayed in the window alert text?
   > Your answer here

The Celebrities() function is what we will use to generate HTML for each celebrity so that they can be displayed. And each celebrity is assocaited with specific info that we encpsulate in HTML elements that will represent each celebrity in the list. Just like we talked about with Kids, you need to generate a list of all the celebrities to have something for users to click on to generate an event that can create a windows alert. Remember how we talked about last answer which is a property on an HTML element that allows us to read/write custom data attributes that can be embedded for later usage via data- syntax. Data-sport attributes can basically allow us to tie a sport to the celebrity within the DOM. 
    for (const star of celebrities) {
        html += `<li 
                    data-id="${star.id}" 
                    data-type="celebrity"
                    data-sport="${star.sport}"
                    data-email="${star.email}">
                    ${star.name} is a ${star.sport}
                </li>`
    }
For this code the data-type is what we need. Just like with Kids, we have an event listener attached to the document to listen for click events and can keep track of where the click event happens via target. So if we click on an <li> element eventListener will keep track of that and we can store the <li> element we clicked on as a variable via 
(clickEvt) => {
        const celebrityTarget = clickEvt.target
Again before creating any windows alert to display the sport a celebrity plays we have to verify the element actually clicked on was of type celebrity via        if(celebrityTarget.dataset.type === "celebrity"){. This is why the datatype I talked about earlier is crucial. We also need dataset to get the value of the celebrity ID for the celebrity in the <li> that the user clicked on via         const celebrityId = celebrityTarget.dataset.id(whch again is going to be represented as a string that must be parsed later on). From there it is similar logic to other modules          
for(const celeb of celebrities){
                if(celeb.id === parseInt(celebrityId)){
. We iterate through every celebrity in the celebrity array we get from the DB via const celebrities = getCelebrities() and when we find a celebrity ID that is equal to the celebrity of the li element we clicked(ie    const celebrityId = celebrityTarget.dataset.id ) now we can create our windows alert as you see below 
  if(celeb.id === parseInt(celebrityId)){
                    window.alert(` ${celeb.name} is a ${celebrityTarget.dataset.sport} star`);
                }
            }
Again the dataset HTML attribute allows us direct access to the li element we clicked on and the sport value fo that particular celebrity. Note we could have also used celeb.sport because the celeb.id is equal to the celebrity of the <li> element we clicked on. 

From here we can create a message to display in the windows alert via a combination of static text and dynamic data that we have retrieved from the dataset. Window.alert will trigger a dialog box that presents the message ot the user. The user can dismiss the alert to be able to interact with the page again. 



4. Can you describe, in detail, the algorithm that is in the `main` module?
   > Your answer here

Everything starts with the index.html. It is the initial entry point when a user will visit the web page. 
<main id="container"> is the container that holds the content generated by the main.js. The line <script type="module" src="./scripts/main.js"></script> is what allows for the generation of this content via teh script. By placing this at the bottom we are ensuring the script is loaded and excuted after the HTML has been parsed by the browser. I bring this up because the main.js is essentially going to manipulate teh DOM, and in order to do so we already need the elements to be present. 

The main module role is to set up the initial structure of the web page by loading the necessary content and by loading the Kids Celebrities and Pairing modules, which in doing so not only generates HTML strings that can be injected into the container in main.js for rendering but also allows the application to have an event listener set up to be ready to listen for events. Look at the first line of main.js 
const mainContainer = document.querySelector("#container")

it queries the DOM to define our container and capture the <main> element from index.html. This now allows our main.js script to have a reference point where it can inject the generated HTML content which is what the main.js will do as we will discuss below. 

From this, main.js can generate HTML content to insert into our mainContainer by invoking 3 functions Kids() Celebrities() Pairings(). They will generate specific sections of the page when called below based off data they manage. by using dataset as we talked about previously several times we can also embed relevant info into the HTML elements. 
const applicationHTML = `
    <h1>Make a Memory for Kids</h1>
    <article class="details">
        <section class="detail--column list details__kids">
            <h2>Kids</h2>
            ${Kids()}
        </section>
        <section class="detail--column details__celebrities">
            <h2>Celebrities</h2>
            ${Celebrities()}
        </section>
    </article>

    <article class="assignments">
        <h2>Pairings</h2>
        ${Pairings()}
    </article>

    Each of these functions will generate its own HTML string based off string interpolation derives from using values from the database that it calls, and storing values in HTML elements via datasets that it can retrieve for usage when needed. But as you can see above the generated HTML from each of these functions is assembled into a larger template string called applicationHTML. The <h1> header helps give an introduction to the page. <article class=details> has a section for kids to list their names/wishes and a section for celebrities with their names/sports. <article class="assignments"> contains the list of pairings between kids and celebrities. Once these functions are called and the applicationHTML string is done being generated, we call mainContainer.innerHTML = applicationHTML which allows main.js to inject the applicationHTML content into the main container element. So all the HTML represented in applicationHTML can now be rendered inside the <main id="container"> element inside index.html. 

    The other part of all this is the event listener after the HTML content is generated and inserted into the DOM(ie lets say we call ${Kids()}) This content for Kids becomes immeadiately visible on the page as soon as its inserted. Now notice in our code after the Celebrities() and Kids () functions we added document.addEventListener(. The way we set this up these will be executed AFTER the content is generated for each module(ie in our ex the eventListener will only be set up after the Kids() function is run generating our HTML). What I learned reading about this was that the event listener will listen for events(in our case clicks) across the ENTIRE document as soon as this is set up. So in our ex we set up the HTML for kids via Kids(), add our event listener and that event listener can also listen for any events that happen within the document, including elements we add to the DOM later dynamically(like the Celebrities via Celebrities()). So in theory you only need 1 event listener and we could have set up the code like this 
document.addEventListener("click", (event) => {
    const target = event.target;

    // Check if the clicked element is a celebrity
    if (target.dataset.type === "celebrity") {
        // Handle celebrity clicks
    }

    // Check if the clicked element is a pairing
    if (target.dataset.type === "kids") {
        // Handle kids clicks
    }
    It's easier(especially for our sakes) to just define multiple even listeners rather than go back and forth between 1 but this is something we could have done reading into it. Note that when I say "read the entire document" it can only listen to events we hae set up listeners for. Your listener callback function needs to be aware of elements in order to respond to them and in our case we did not set up an event listener for Pairings so no without doing documents.addEventListener and specifying logic for when target.dataset.type = "pairing" the pairing element wont be interactive and respond to events on it. 